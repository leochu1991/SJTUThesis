%# -*- coding: utf-8-unix -*-
%%==================================================
%% chapter_4.tex for SJTU Master Thesis
%%==================================================

\chapter{统计策略在晶振源补偿和透明时钟中的应用及统计算法仿真}
在第\ref{chap:statistical_delay}章中，从链路传输延时的角度，通过深入分析实际工业环境下对链路传输延时的影响，通过对链路传输延时建立细致的数学模型，并从数学统计的角度对其中各个影响因素提出了有针对性的解决方案。

至此，已经能够利用上述算法综合获得稳定和精确的链路延时。但是，仅仅获取稳定精确的链路延时并不是时钟同步的终点。想要提高同步精度意味着必须得出准确的主从偏差值offset，并对从时钟进行校正。但是，主从偏差值会由于晶振源频率波动而变化，所以依据常规的同步算法并不能消除这个问题。为了能够计算得到准确的offset，下面将采取的做法是对从时钟晶振频率进行补偿，从而使的主从时钟频率尽可能保持一致，从而消除offset波动所带来的问题。

另外，本章节还将介绍如何将稳中提到的统计算法应用到透明时钟中，由于透明时钟与边界时钟的根本差异，需要对统计算法进行调整才能更好的应用到透明时钟中。

\section{主从时钟源频率漂移}
由于在工业现场中采用的ptp时钟设备内部都是通过晶振来计时的，或者说内部时钟就是通过晶振的计数来实现的。然后，晶振本身物理特性比较复杂，一般用以下两个属性来进行描述：准确度和稳定度。所谓准确度就是系统误差，而稳定度就是随机误差。在1588同步协议中，晶振的频率和频偏都会影响到时钟的同步精度。但是，IEEE1588协议中假设在一次同步周期中，主从时钟的偏差会保持不变。然而实际上，虽然主时钟采用高稳时钟，稳定性较高，但是从时钟采用普通晶体振荡器，这使得从时钟频率与标准频率相比存在漂移，也就造成了主从时钟偏差一直处于变化中，也就是说，真实的情况并不满足协议中假设的那样主从偏差保持不变。

因此，由于由于从时钟晶振源的自身漂移，导致了主从时钟之间的偏差处于不断变化中。所以，应该采取手段来补偿从时钟晶振源的漂移，使得主从时钟晶振源保持一致，从而尽可能减小晶振源漂移造成的误差。

\subsection{晶振漂移对1588同步精度的影响}
由于晶振源的精度会同时受到外部环境和内部因素的共同影响，所以实际对外的输出频率是不断变化的。用$f_{output}$表示晶振源对外输出的频率，$f_{standard}$表示标称频率，D表示频率漂移程度，那么可以得到：
\begin {align}
D = \frac{f_{output} - f_{standard}}{f_{standard}}
\end{align}
而在真实的ptp同步系统中，由于主时钟一般采用高稳时钟，所以可以认为主时钟的漂移非常小以至可以忽略，那么假设主从时钟频率漂移为$f_{delta}$，计算方式如下:
\begin {align}
f_{delta} = D * f_{standard}
\end{align}
也就是说，假设一次同步周期为$T_{sync}$，则一次sync过程中主从时钟源的固有漂移值为:
\begin {align}
T_{delta} = D * \frac{f_{delta} * T_{sync}}{f_{standard}}
\end{align}
其中，$T_{delta}$就是一次同步周期内最大的时钟漂移。随着时间的流逝，这种漂移不会不会改善，而且会使得主从晶振源频率漂移越来越大，造成了漂移时间也越来越大，严重破坏了同步精度。

因此，必须对从时钟晶振漂移进行合适的补偿，使得每次同步周期中，从时钟的频率能够进一步靠近主时钟，从而减小频率漂移带来的不良影响。

\subsection{统计算法在频率补偿中的应用}
为了补偿从时钟频率，需要通过一种手段来测量主从时间的频率差值。这里采用的方法就是利用Sync报文的周期性发送，即主时钟是每隔$T_{m}$时间段发送一次Sync报文，而从时钟也是每隔$T_{s}$时间段收到一次Sync报文，假设主从时钟的频率是一致的，那么$T_{m}$就应该接近于$T_{s}$。然而实际上，由于从时钟频率漂移，使得从时钟的计数方式收到影响，导致$T_{s}$并不等于$T_{m}$，不过，正好可以利用这个特性来估算主从时钟的频率差值。

不过，要注意的是，$T_{m}$与$T_{s}$不完全相等并不一定是从时钟漂移所带来的，还有可能是链路上传输的时间波动，导致Sync报文的发送和接收周期不一致。所以，不可以仅仅根据一次Sync报文的发送、接收周期来计算频率差值。针对这样的情况，下文提出了一种基于统计算法的频率补偿方法，下面进行详细介绍：

由于在上面的统计算法中，累积了很多的sync报文样本，可以利用这些sync报文来进行统计分析。
\begin{table}[htpb]
  \centering
  \bicaption[tab:dynamic_threshold]{sync报文收发时间戳}{sync报文收发时间戳}{Table}{Timestamp for send and receive of sync message}
  \begin{tabular}{llllll} \toprule
    sync次序 & 1 & 2 & 3 & $\cdots$ & n \\ \midrule
    当前sync报文发送时间 & $t_{s1}$ & $t_{s2}$ & $t_{s3}$ & $\cdots$ & $t_{sn}$ \\ \midrule
    当前sync报文接收时间 & $t_{r1}$ & $t_{r2}$ & $t_{r3}$ & $\cdots$ & $t_{rn}$  \\ \bottomrule
  \end{tabular}
\end{table}

上面的表格可以很容易通过之前的样本数据得到，有了每个sync报文的发送接收时间后，可以很简单的计算出sync报文的发送接收周期波动值。
\begin{table}[htpb]
  \centering
  \bicaption[tab:dynamic_threshold]{sync报文收发周期}{sync报文收发周期}{Table}{Loop for send and receive of sync message}
  \begin{tabular}{llllll} \toprule
    编号 & 1 & 2 & 3 & $\cdots$ & n \\ \midrule
    sync报文主时钟发送周期 & $T_{m1}$ & $T_{m2}$ & $T_{m3}$ & $\cdots$ & $T_{mn}$ \\ \midrule
    sync报文从时钟接收周期 & $T_{s1}$ & $T_{s2}$ & $T_{s3}$ & $\cdots$ & $T_{sn}$  \\ \bottomrule
  \end{tabular}
\end{table}

因此，能够得到主从时钟的周期样本，利用这些样本，可以采用均值法来计算主从时钟的周期，设主时钟平均周期为$T_{m}$，从时钟平均周期为$T_{s}$，那么可以得到主从时钟频率偏差为：
\begin {align}
f_{delta} = \frac{1}{T_{m}} - \frac{1}{T_{s}}
\end{align}
利用$f_{delta}$即可对从时钟频率进行校正。

\section{统计算法在透明时钟中的应用}
透明时钟是一种新的ptp设备类型，虽然它应用范围不如边界时钟更广，而且其本身需要成本更高，不过为了算法完整性，文中决定对于这类设备的同步优化进行分析。下面的分析主要针对透明时钟与边界时钟的差异性，来分析四种算法暂时性时延抖动优化算法，持久性时延变化优化算法，时延固有波动优化算法和主从时钟源频率补偿算法的调整。

\subsection{透明时钟与边界时钟差异性}
透明时钟(Transparent Clock, TC)是1588v2中引入的一种新的ptp设备类型，它的基本原理是通过内部驻留时间桥来测量事件消息在通过设备时的驻留时间，然后把驻留时间存储到事件消息的修正域中。当从时钟接收到该报文时，可以通过解析修正域而得知该报文在链路传输过程中所经历的传输时间。

透明时钟有两种工作机制：
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
  \item 端对端透明时钟(End to End TC)。这种工作机制下，透明时钟将转发所有符合网络规则的报文，同时测量出时间消息驻留时间，并把测量结果作为修正值累计啊到事件消息的修正域中；
  \item 点对点透明时钟(Peer to Peer TC)。这种工作机制下，透明时钟每个端口上额外添加一个延时测量模块，这个模块可以计算在该练路上，执行相同机制的对方端口之间的链路传输延时。所以说，点对点透明时钟不仅可以修正驻留时间，还能对端口之间的链路传输延时进行修正。不过，它只会对Sync报文和Followup报文进行处理，丢弃DelayReq和DelayResp报文。
\end{itemize}

依据上述透明时钟的原理，可以将其与边界时钟进行比较得到以下几个不同点：
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
  \item 首先，边界时钟完全无法测量链路传输延时，而透明时钟可以计算在设备内部的驻留时间，因此，即使报文在传输过程中，遭遇排队或堵塞等暂时性时延波动，从时钟仍然能够通过减去修正域的值来消除其影响；
  \item 另外，假设链路发生了拓扑结构变化，所有报文的传输路径变动，依然可以利用透明时钟的特性消除因此带来的链路传输延时持久性变化。
\end{itemize}

\subsection{统计算法在透明时钟中的调整与优化}
由于边界时钟与透明时钟的固有差异，如果想把上述的统计算法应用到透明时钟，则需要做出一些调整。而有余透明时钟比边界时钟更高级，能够很好的衡量报文传输路径中消耗的延时，所以，如果在实际系统中采用了透明时钟，那么能够极大简化统计算法，也能够得到更好的同步精度。但是，目前工业应用中，透明时钟并没有完全替代边界时钟，一方面由于透明时钟成本更高，另一方面由于透明时钟的推出时间晚于边界时钟，工业中很多同步场合已经采用了边界时钟同步架构。

对于透明时钟，由于它能够较好的测量链路传输延时，那么可以作出以下调整：
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
  \item 暂时性时延抖动算法：由于暂时性时延抖动主要源自中间设备内部的排队和堵塞，而透明时钟能够把这些时间添加到修正域中，因此即使设备发生排队现象，仍然能在从时钟处很好的消除这部分时间的变化，因此，如果一条链路中全部采用了透明时钟，那么可以不需要考虑此类时延抖动。不过，如果链路中同时采用了边界时钟与透明时钟，那么仍然有必要考虑算法实现；
  \item 持久性时延变化算法：所谓持久性时延变化主要来自于链路拓扑结构的变化，一旦链路变化，那么报文的链路传输时间则会发生变化，而对于统计算法而言，这也就意味着之前的统计样本统统失效。在透明时钟中，会减去设备内部的时间波动，那么只有纯粹链路的传输时间变化会导致样本的移动，不过，一般而言，纯粹路径耗时非常微小，所以可以当作持久性时延变化不会对透明时钟有很大影响；
  \item 时延固有波动算法：对于时延固有波动，无论透明时钟还是边界时钟都是无法消除的，所以，仍然要针对固有波动进行统计处理，以减小时延的波动造成从时钟源的波动，提高从时钟稳定性；
  \item 主从时钟源频率补偿算法：主从时钟源与中间传输设备没有太大关联，无论是边界时钟还是透明时钟，都需要进行频率补偿。只不过，由于该算法是利用Sync报文的发送周期与接收周期的差异来进行优化的，所以会受到Sync报文传输时间的影响，如果Sync报文路径传输时间变长，那么接收周期变大，导致计算出现偏差。所以，对于透明时钟而言，可以忽略报文传输的时间变化，因此透明时钟在频率补偿时会有更好的精度。
\end{itemize}

\section{基于stateflow搭建的PTP仿真系统进行统计算法验证}
为了能够对本论文中所提出的优化算法进行验证，在实验室师兄的基础上，继续利用stateflow工具，搭建并优化了基于IEEE1588协议的时钟同步系统。为了能够实现仿真验证，该系统中创建了三台ptp时钟，包括两个普通时钟和一个边界时钟，其中一个普通时钟扮演Grand Master的角色，另一个时钟扮演从时钟角色。边界时钟在二者中间，与GM时钟进行同步，同时向从时钟发送Sync报文，最终达到三者处于同步。

下面仅对该仿真系统中比较重要的部分进行介绍，同时利用该系统来进行仿真验证上文所提算法。

\subsection{仿真系统搭建及介绍}
Simulink Stateflow工具箱是matlab平台上的一种可视化建模工具，对于状态机、流程图等的创建，或者对PTP时钟同步系统之类事件驱动系统进行建模仿真具有非常良好的应用性。

下面对其中与本文算法相关的一些模块进行简要地介绍，不作过多赘述。

\subsubsection{本地时钟模块}
本地时钟模块：该模块为时钟模块提供本地时钟，对同步系统而言，就是要让从时钟的本地时钟模块能够在算法校正后实现与主时钟本地时钟模块保持一致，才算达到良好的同步效果。在实际系统中为晶振驱动，在仿真模型中，使用脉冲生成器来驱动，在每个脉冲上升沿处使的脉冲计数器加pulseCount值，另外设rate值来调节本地时钟精度。例如，使用的脉冲器为100MHz，那么脉冲计数器pulseCount每次累加10ns，如果用rate＝100，那么表示每100个10ns对应1个时钟clock，即1微秒。用clockCount来表示本地时钟，每产生一个clock就使clockCount加1。另外，由于真实的时钟还存在频率偏差，为了模仿这种情况，再给pulseCount添加一个偏差值，frequncyOffset，即：
\begin{align}
  clockCount = (pulseCount + frequncyOffset) / rate
\end{align}
对于该频率偏差frequncyOffset，应该用时钟伺服系统来进行校正。
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=12cm]{simulation_local_clock}
    \bicaption[fig:simulation_local_clock]{本地时钟仿真模型}{本地时钟仿真模型}{Fig}{The Simulation model of Local Clock}
  \end{minipage}     
\end{figure}

\subsubsection{定时器模块}
由于同步系统中存在很多中定时触发或超时事件，例如Sync报文的周期性发送，Announce报文的超时等待事件等。所以，添加了这个模块，为系统中所有周期性或有超时发生的事件进行触发。

下图是Announce超时事件定时器模块作为参考，其他定时器模块与之非常类似。
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=12cm]{simulation_announce_timeout_timer}
    \bicaption[fig:simulation_announce_timeout_timer]{Announce报文超时事件定时器仿真模型}{Announce报文超时事件定时器仿真模型}{Fig}{The Timer model for Announce message receipt timeout}
  \end{minipage}     
\end{figure}

\subsubsection{报文收发模块}
该模块主要包括每个时钟内部对外的收发报文。对于接收模块，它会时钟监听某外部信号，一旦有报文传入则会立即触发系统进入报文接受流程，该流程会讲所收到报文的数据全部存储到本地，同时向系统中发出报文接受完成信号。对于发送模块，会先把数据根据对应报文格式组装成对应的报文，把数据存入该报文中，然后从时钟对应的端口发出。
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=12cm]{simulation_message_receive}
    \bicaption[fig:simulation_message_receive]{报文接收模块仿真模型}{报文接收模块仿真模型}{Fig}{The model for receiving message}
  \end{minipage}     
\end{figure}
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=12cm]{simulation_message_send}
    \bicaption[fig:simulation_message_send]{报文发送模块仿真模型}{报文发送模块仿真模型}{Fig}{The model for sending message}
  \end{minipage}     
\end{figure}

\subsection{算法仿真思路及指标分析}
下面，为了能够在stateflow仿真平台上验证上述所提统计算法的有效性，下面将从以下几个角度来进行模拟与验证。
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
  \item 对于传输延时抖动，可以在传输中添加随机延时噪声来进行验证；
  \item 对于暂时性时延突变，可以对传输延时添加阶跃噪声，并观察对同步过程的影响；
  \item 对于持久性变化，可以在运行时链路传输中添加永久性固有延时，并观察结果；
  \item 对于控制策略，可以分别采取PI控制器校正和基于神经网络PID控制策略进行同步效果对比。
\end{itemize}

为了验证本文所提的优化算法，下面会在整个同步系统外部，通过监听主时钟和从时钟的时钟偏差曲线，从而可以知道该同步系统的同步性能。主要的比较指标有下面几点：
\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
  \item 偏差值：通过观察主从时钟的偏差值，可以看出该同步系统的同步效果，这也能直接反映真实的同步精度。因此，可以以此来检测同步系统中链路延时抖动和“暂时性”抖动对同步精度造成的影响。
  \item 鲁棒性：当系统中发生“持久性”时延变化，那么会造成从时钟发生较大的抖动，所以，可以依据此来检测针对“持久性”时延变化的优化算法的效果，如果该优化算法能够使的从时钟的抖动减小，那么表示从时钟的鲁棒性得到了提高。
  \item 收敛速度及稳定性：可以通过观察主从偏差的波动值，并计算其收敛时间。尤其是在链路环境发生变化，即类似工业环境中的多种复杂因素导致系统不稳定，以此来观察系统的收敛速度和最终的稳定性，从而来判断本文提出的基于神经网络的PID控制器的效果。
\end{itemize}

\section{对链路时延的数学统计算法的验证}
为了验证上文中提到的“最小二乘线性回归算法”，“动态阈值法”和“实时动态监控算法”的实际效果，下面一次对这三种算法进行验证。在验证中，可以通过认为模拟延时抖动、排队堵塞和拓扑结构变化等因素导致的时延变化，通过比较采用相关算法前后的同步曲线来得出相关结论。

下文中的同步曲线是指从时钟与主时钟之间的随时间变化的实时同步偏差曲线。

\subsection{验证“最小二乘线性回归算法”对延时抖动的优化}
为了验证“最小二乘线性回归算法”对延时抖动的优化效果，可以在从时钟计算链路传输延时时添加随机扰动，并模拟该扰动符合标准正态分布，得到下面两个仿真结果。见对比图\ref{fig:添加正态分布的随机抖动后的同步曲线}与\ref{fig:添加正态分布随机抖动且利用最小二乘处理后的同步曲线}。
首先，为了模拟生产环境中的随机噪声，在传输链路中加入服从正态分布的随机影响因子，然后进行同步，可以得到下面的同步曲线：
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=8cm]{matlab/添加正态分布的随机抖动后的同步曲线.PNG}
    \bicaption[fig:添加正态分布的随机抖动后的同步曲线]{添加正态分布随机抖动的常规同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{添加正态分布随机抖动的常规同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve, within Normal Distribution random noise}
  \end{minipage}     
\end{figure}

\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=8cm]{matlab/添加正态分布随机抖动且利用最小二乘处理后的同步曲线.PNG}
    \bicaption[fig:添加正态分布随机抖动且利用最小二乘处理后的同步曲线]{添加正态分布随机抖动且利用最小二乘处理后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{添加正态分布随机抖动且利用最小二乘处理后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve dealing with least square method, within Normal Distribution random noise}
  \end{minipage}     
\end{figure}

通过上面的对比曲线，可以明显看出，利用最小二乘法处理后可以明显减小随机噪声对同步结果的影响，从时钟振动幅度减小，从时钟具有更好的同步效果。说明该线性回归算法能够很好的减小随机抖动对从时钟系统的影响。

\subsection{验证“动态阈值法”对“暂时性”时延突变的优化}
为了模拟“暂时性”时延变化，在同步系统运行中间，突然加入一个时延突变，并保持一小段时间。并分别仿真出采用“动态阈值法”前后的时钟同步曲线。见对比图\ref{fig:添加暂时性时延突变后的同步曲线}和\ref{fig:添加暂时性时延突变并采用动态阈值法处理后的同步曲线}。

首先，为了模拟暂时性时延突变，在仿真接近2秒时，为链路传输延时添加一个阶跃信号，并观察其同步曲线情况，可以得到如下结果：
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=7cm]{matlab/添加暂时性时延突变后的同步曲线.PNG}
    \bicaption[fig:添加暂时性时延突变后的同步曲线]{添加暂时性时延突变后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{添加暂时性时延突变后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve, within temporary time-delay mutation}
  \end{minipage}     
\end{figure}

然后，保持上面的阶跃信号不变，采用文中提出的“动态阈值法”来进行优化，可以得到如下的结果：
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=7cm]{matlab/添加暂时性时延突变并采用动态阈值法处理后的同步曲线.PNG}
    \bicaption[fig:添加暂时性时延突变并采用动态阈值法处理后的同步曲线]{添加暂时性时延突变后，采用“动态阈值法”处理前后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{添加暂时性时延突变后，采用“动态阈值法”处理前后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve with dynamic threshold value method, within temporary time-delay mutation}
  \end{minipage}     
\end{figure}

通过上面的对比曲线，可以明显看出，利用了“动态阈值法”对阶跃噪声进行优化后，从时钟的瞬间振荡明显减小，这意味着从时钟具备了更好的鲁棒性和稳定性，不会轻易随着网络负载变化而发生较大波动。

\subsection{验证“实时动态监控算法”对“持久性”时延变化的优化}
为了模拟“持久性”时延变化，在同步系统运行中间，加入一个恒定的时延变化，并保持不变。然后分别仿真出采用“实时动态监控算法”前后的时钟同步曲线。见对比图\ref{fig:添加持久性时延变化后样本逐步覆盖的同步曲线}与\ref{fig:添加持久性时延突变后，采用“实时动态监控算法”处理前后的同步曲线}。

为了模拟持久性延时变化，给链路延时添加固定的增量，并且保持不变，然后可以得到如下的同步曲线：

\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=8cm]{matlab/添加持久性时延变化后样本逐步覆盖的同步曲线.PNG}
    \bicaption[fig:添加持久性时延变化后样本逐步覆盖的同步曲线]{添加持久性时延变化后样本逐步覆盖的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{添加持久性时延变化后样本逐步覆盖的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve, within persistence time-delay change}
  \end{minipage}     
\end{figure}

然后，保持上面的固定增量，采用动态监控方法来进行处理，可以得到同步曲线\ref{fig:添加持久性时延突变后，采用“实时动态监控算法”处理前后的同步曲线}。

\begin{figure}[htbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=10cm]{matlab/添加持久性时延变化后实时监控处理后的同步曲线.PNG}
    \bicaption[fig:添加持久性时延突变后，采用“实时动态监控算法”处理前后的同步曲线]{添加持久性时延变化后实时监控处理后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{添加持久性时延变化后实时监控处理后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve with real-time dynamic monitoring method, within persistence time-delay change}
  \end{minipage}     
\end{figure}

可以发现，利用“实时动态监控算法”对“持久性”时延变化进行实时监控后，可以在系统中发生“持久性”时延变化后通过实时监控能够迅速发现该变化，然后采取相关措施后使得同步过程快速恢复正常，这提高了同步系统对外界变化的快速响应性。


\subsection{验证统计策略对“晶振源频率补偿”的优化效果}
为了在仿真系统中模拟从时钟晶振源漂移的情况，假设要模拟从时钟频率在不断衰减，即时间周期越来越长这样一种情况，那么可以给从时钟频率添加一个固定的衰减，使得从时钟的频率处于不断的小幅衰减中。然后，再利用上面提出来的频率补偿算法，不断的对从时钟频率进行补偿，以保持主从时钟源频率尽可能的一致。

下面，先给从时钟源频率加上一个固定的衰减值，并观测主从时钟偏差的变化情况，可以得到同步曲线\ref{fig:为从时钟源频率添加固定衰减后的同步曲线}。
\begin{figure}[!hbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=10cm]{matlab/a默认晶振源漂移主从偏差.jpg}
    \bicaption[fig:为从时钟源频率添加固定衰减后的同步曲线]{为从时钟源频率添加固定衰减后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{为从时钟源频率添加固定衰减后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve, within persistence time-decrease in slave clock}
  \end{minipage}     
\end{figure}

可以看出主从时钟源的偏差处于不断的波动之中。然后，为从时钟频率进行补偿，可以得到同步曲线\ref{fig:采用晶振源频率补偿算法后的同步曲线}。
\begin{figure}[htbp]
  \centering
  \begin{minipage}[b]{1\textwidth}
    \captionstyle{\centering}
    \centering
    \includegraphics[width=10cm]{matlab/a晶振源漂移补偿后主从偏差.jpg}
    \bicaption[fig:采用晶振源频率补偿算法后的同步曲线]{采用晶振源频率补偿算法后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{采用晶振源频率补偿算法后的同步曲线(横坐标:时间/s，纵坐标:主从时钟偏差/ns)}{Fig}{The Synchronization curve by frequency compensation, within persistence time-decrease in slave clock}
  \end{minipage}     
\end{figure}

通过上面的比较，可以看出，不使用频率补偿时，由于从时钟频率漂移导致主从时间差越来越大，需要校正的幅度也越来越大，所以会出现较大的波动。但是当对从时钟频率进行补偿后，使得主从时钟的频率更加接近，削弱了从时钟漂移带来的偏差，使得主从时钟同步的幅度减小，也更加的稳定。



